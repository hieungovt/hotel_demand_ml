---
title: "Data Preparation"
---

# Data Preparation {#sec-data-preparation}

The third phase of CRISP-DM involves all activities to construct the final dataset that will be used for modeling. This includes data cleaning, feature engineering, and transformation.

```{python}
#| label: setup
#| output: false

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.preprocessing import LabelEncoder, StandardScaler
from sklearn.model_selection import train_test_split
import warnings

warnings.filterwarnings('ignore')
plt.style.use('seaborn-v0_8-whitegrid')

# Load raw data
df_raw = pd.read_csv('../data/raw/hotel_bookings.csv')
print(f"Original dataset: {df_raw.shape[0]:,} rows, {df_raw.shape[1]} columns")
```

## Data Cleaning

### Step 1: Handle Missing Values

```{python}
#| label: missing-values

df = df_raw.copy()

print("Missing values before cleaning:")
missing = df.isnull().sum()
print(missing[missing > 0])

# 1. Fill missing children with 0
df['children'] = df['children'].fillna(0)

# 2. Fill missing country with 'Unknown'
df['country'] = df['country'].fillna('Unknown')

# 3. Handle agent and company columns
# These appear as numeric but have actual values we need
# Convert NULL string to 0 (means direct booking / no company)
df['agent'] = pd.to_numeric(df['agent'], errors='coerce').fillna(0)
df['company'] = pd.to_numeric(df['company'], errors='coerce').fillna(0)

print("\nMissing values after cleaning:")
print(df.isnull().sum().sum(), "total missing values")
```

### Step 2: Remove Invalid Records

```{python}
#| label: remove-invalid

initial_count = len(df)

# Remove bookings with 0 guests (data error)
df = df[(df['adults'] + df['children'] + df['babies']) > 0]
removed_zero_guests = initial_count - len(df)
print(f"Removed {removed_zero_guests:,} bookings with 0 guests")

# Remove negative ADR values
before = len(df)
df = df[df['adr'] >= 0]
removed_neg_adr = before - len(df)
print(f"Removed {removed_neg_adr:,} bookings with negative ADR")

# Cap extreme ADR outliers
adr_99 = df['adr'].quantile(0.99)
print(f"\n99th percentile ADR: €{adr_99:.2f}")
before_extreme = (df['adr'] > adr_99).sum()
df = df[df['adr'] <= adr_99]
print(f"Removed {before_extreme:,} extreme ADR outliers")

print(f"\nFinal dataset: {len(df):,} rows ({len(df)/len(df_raw)*100:.1f}% of original)")
```

### Step 3: Data Type Corrections

```{python}
#| label: data-types

# Ensure correct data types
df['children'] = df['children'].astype(int)
df['agent'] = df['agent'].astype(int)
df['company'] = df['company'].astype(int)

# Verify types
print("Data types after correction:")
print(df.dtypes)
```

## Feature Engineering

### Step 4: Create Derived Features

```{python}
#| label: feature-engineering

# Total nights stayed
df['total_nights'] = df['stays_in_weekend_nights'] + df['stays_in_week_nights']

# Total guests
df['total_guests'] = df['adults'] + df['children'] + df['babies']

# Is weekend stay (binary)
df['is_weekend_stay'] = (df['stays_in_weekend_nights'] > 0).astype(int)

# Lead time buckets (categorical)
df['lead_time_bucket'] = pd.cut(
    df['lead_time'],
    bins=[-1, 7, 30, 90, 180, 365, float('inf')],
    labels=['0-7', '8-30', '31-90', '91-180', '181-365', '365+']
)

# Arrival month as number
month_mapping = {
    'January': 1, 'February': 2, 'March': 3, 'April': 4,
    'May': 5, 'June': 6, 'July': 7, 'August': 8,
    'September': 9, 'October': 10, 'November': 11, 'December': 12
}
df['arrival_month_num'] = df['arrival_date_month'].map(month_mapping)

# Season based on arrival month
month_to_season = {
    1: 'Winter', 2: 'Winter', 3: 'Spring',
    4: 'Spring', 5: 'Spring', 6: 'Summer',
    7: 'Summer', 8: 'Summer', 9: 'Fall',
    10: 'Fall', 11: 'Fall', 12: 'Winter'
}
df['season'] = df['arrival_month_num'].map(month_to_season)

# Full arrival date for time series
df['arrival_date'] = pd.to_datetime(
    df['arrival_date_year'].astype(str) + '-' +
    df['arrival_month_num'].astype(str) + '-' +
    df['arrival_date_day_of_month'].astype(str),
    errors='coerce'
)

# Room type match (was guest assigned requested room?)
df['got_reserved_room'] = (df['reserved_room_type'] == df['assigned_room_type']).astype(int)

# Total revenue (ADR * nights)
df['total_revenue'] = df['adr'] * df['total_nights']

print("New features created:")
new_features = ['total_nights', 'total_guests', 'is_weekend_stay', 
                'lead_time_bucket', 'arrival_month_num', 'season', 
                'arrival_date', 'got_reserved_room', 'total_revenue']
for feat in new_features:
    print(f"  - {feat}: {df[feat].dtype}")
```

### Visualize New Features

```{python}
#| label: fig-new-features
#| fig-cap: "Distribution of Engineered Features"

fig, axes = plt.subplots(2, 3, figsize=(15, 10))

# Total nights distribution
axes[0, 0].hist(df['total_nights'], bins=30, color='#3498db', edgecolor='white')
axes[0, 0].set_xlabel('Total Nights')
axes[0, 0].set_title('Total Nights Distribution', fontweight='bold')

# Total guests
axes[0, 1].hist(df['total_guests'], bins=range(1, 10), color='#2ecc71', edgecolor='white')
axes[0, 1].set_xlabel('Total Guests')
axes[0, 1].set_title('Total Guests Distribution', fontweight='bold')

# Lead time bucket vs cancellation
lead_cancel = df.groupby('lead_time_bucket', observed=False)['is_canceled'].mean() * 100
bars = axes[0, 2].bar(range(len(lead_cancel)), lead_cancel.values, 
                      color=plt.cm.Reds(np.linspace(0.3, 0.9, len(lead_cancel))))
axes[0, 2].set_xticks(range(len(lead_cancel)))
axes[0, 2].set_xticklabels(lead_cancel.index, rotation=45)
axes[0, 2].set_ylabel('Cancellation Rate (%)')
axes[0, 2].set_title('Cancellation by Lead Time Bucket', fontweight='bold')

# Season distribution
season_order = ['Winter', 'Spring', 'Summer', 'Fall']
season_counts = df['season'].value_counts().reindex(season_order)
axes[1, 0].bar(season_counts.index, season_counts.values, 
               color=['#3498db', '#2ecc71', '#f39c12', '#e74c3c'])
axes[1, 0].set_ylabel('Number of Bookings')
axes[1, 0].set_title('Bookings by Season', fontweight='bold')

# Got reserved room impact
room_match = df.groupby('got_reserved_room')['is_canceled'].mean() * 100
bars = axes[1, 1].bar(['Different Room', 'Got Reserved Room'], room_match.values,
                      color=['#e74c3c', '#2ecc71'])
axes[1, 1].set_ylabel('Cancellation Rate (%)')
axes[1, 1].set_title('Room Assignment Impact', fontweight='bold')
for bar, val in zip(bars, room_match.values):
    axes[1, 1].text(bar.get_x() + bar.get_width()/2, bar.get_height() + 1,
                   f'{val:.1f}%', ha='center', fontweight='bold')

# Total revenue distribution
axes[1, 2].hist(df[df['total_revenue'] < 2000]['total_revenue'], bins=50, 
                color='#9b59b6', edgecolor='white')
axes[1, 2].set_xlabel('Total Revenue (€)')
axes[1, 2].set_title('Revenue Distribution', fontweight='bold')

plt.tight_layout()
plt.show()
```

## Prepare Data for Modeling

### Classification Data Preparation

```{python}
#| label: classification-prep

# Define feature columns for classification
feature_cols = [
    'lead_time', 'arrival_date_week_number', 'arrival_month_num',
    'stays_in_weekend_nights', 'stays_in_week_nights', 'adults',
    'children', 'babies', 'is_repeated_guest', 'previous_cancellations',
    'previous_bookings_not_canceled', 'booking_changes',
    'days_in_waiting_list', 'adr', 'required_car_parking_spaces',
    'total_of_special_requests', 'total_nights', 'total_guests',
    'is_weekend_stay', 'got_reserved_room'
]

# Categorical features to encode
cat_cols = ['hotel', 'meal', 'market_segment', 'distribution_channel',
            'deposit_type', 'customer_type', 'season']

print(f"Numerical features: {len(feature_cols)}")
print(f"Categorical features: {len(cat_cols)}")
```

### Encode Categorical Variables

```{python}
#| label: encode-categorical

# Prepare feature matrix
X = df[feature_cols].copy()

# Encode categorical features using LabelEncoder
label_encoders = {}
for col in cat_cols:
    if col in df.columns:
        le = LabelEncoder()
        X[col] = le.fit_transform(df[col].astype(str))
        label_encoders[col] = le
        print(f"{col}: {len(le.classes_)} classes -> {list(le.classes_)[:5]}...")

# Target variable
y = df['is_canceled']

print(f"\nFeature matrix shape: {X.shape}")
print(f"Target shape: {y.shape}")
```

### Train-Test Split

```{python}
#| label: fig-train-test-split
#| fig-cap: "Train-Test Split Visualization"

# Stratified split to maintain class balance
X_train, X_test, y_train, y_test = train_test_split(
    X, y, test_size=0.2, random_state=42, stratify=y
)

print(f"Training set: {X_train.shape[0]:,} samples ({X_train.shape[0]/len(X)*100:.1f}%)")
print(f"Test set: {X_test.shape[0]:,} samples ({X_test.shape[0]/len(X)*100:.1f}%)")

# Visualize class distribution in train/test
fig, axes = plt.subplots(1, 2, figsize=(12, 5))

# Training set
train_counts = y_train.value_counts()
axes[0].pie(train_counts, labels=['Not Canceled', 'Canceled'], 
            autopct='%1.1f%%', colors=['#2ecc71', '#e74c3c'],
            explode=(0, 0.05), shadow=True)
axes[0].set_title(f'Training Set\n({len(y_train):,} samples)', fontweight='bold')

# Test set
test_counts = y_test.value_counts()
axes[1].pie(test_counts, labels=['Not Canceled', 'Canceled'], 
            autopct='%1.1f%%', colors=['#2ecc71', '#e74c3c'],
            explode=(0, 0.05), shadow=True)
axes[1].set_title(f'Test Set\n({len(y_test):,} samples)', fontweight='bold')

plt.tight_layout()
plt.show()

print(f"\nClass balance maintained:")
print(f"  Train: {y_train.mean()*100:.2f}% cancellation")
print(f"  Test: {y_test.mean()*100:.2f}% cancellation")
```

### Time Series Data Preparation

```{python}
#| label: time-series-prep

# Aggregate daily bookings for time series
df_not_canceled = df[df['is_canceled'] == 0].copy()

# Daily booking counts
daily_bookings = df_not_canceled.groupby('arrival_date').agg({
    'hotel': 'count',
    'adr': 'mean'
}).reset_index()

daily_bookings.columns = ['ds', 'y', 'avg_adr']
daily_bookings = daily_bookings.dropna()
daily_bookings = daily_bookings.sort_values('ds')

print(f"Time series data: {len(daily_bookings)} days")
print(f"Date range: {daily_bookings['ds'].min()} to {daily_bookings['ds'].max()}")
print(f"Average daily bookings: {daily_bookings['y'].mean():.1f}")
```

```{python}
#| label: fig-time-series-data
#| fig-cap: "Time Series of Daily Bookings"

fig, axes = plt.subplots(2, 1, figsize=(14, 8))

# Daily bookings
axes[0].plot(daily_bookings['ds'], daily_bookings['y'], 
             color='#3498db', alpha=0.7, linewidth=0.8)
axes[0].set_ylabel('Daily Bookings', fontsize=12)
axes[0].set_title('Daily Booking Arrivals (Non-Canceled)', fontsize=14, fontweight='bold')

# Add rolling average
rolling_avg = daily_bookings['y'].rolling(window=30).mean()
axes[0].plot(daily_bookings['ds'], rolling_avg, 
             color='#e74c3c', linewidth=2, label='30-day Moving Average')
axes[0].legend()

# Average ADR over time
axes[1].plot(daily_bookings['ds'], daily_bookings['avg_adr'], 
             color='#2ecc71', alpha=0.7, linewidth=0.8)
axes[1].set_xlabel('Date', fontsize=12)
axes[1].set_ylabel('Average Daily Rate (€)', fontsize=12)
axes[1].set_title('Average Daily Rate Over Time', fontsize=14, fontweight='bold')

rolling_adr = daily_bookings['avg_adr'].rolling(window=30).mean()
axes[1].plot(daily_bookings['ds'], rolling_adr, 
             color='#e74c3c', linewidth=2, label='30-day Moving Average')
axes[1].legend()

plt.tight_layout()
plt.show()
```

## Save Processed Data

```{python}
#| label: save-data

import os

# Create processed data directory if it doesn't exist
os.makedirs('../data/processed', exist_ok=True)

# Save the cleaned dataset
df.to_csv('../data/processed/hotel_bookings_processed.csv', index=False)
print("Saved: ../data/processed/hotel_bookings_processed.csv")

# Save time series data
daily_bookings.to_csv('../data/processed/daily_bookings.csv', index=False)
print("Saved: ../data/processed/daily_bookings.csv")

# Save train/test splits for reproducibility
train_data = X_train.copy()
train_data['is_canceled'] = y_train.values
train_data.to_csv('../data/processed/train_data.csv', index=False)
print("Saved: ../data/processed/train_data.csv")

test_data = X_test.copy()
test_data['is_canceled'] = y_test.values
test_data.to_csv('../data/processed/test_data.csv', index=False)
print("Saved: ../data/processed/test_data.csv")
```

## Data Preparation Summary

```{python}
#| label: tbl-summary
#| tbl-cap: "Data Preparation Summary"

summary = pd.DataFrame({
    'Step': [
        'Original Dataset',
        'After Missing Value Handling',
        'After Removing Invalid Records',
        'Final Clean Dataset',
        'Features Created',
        'Training Set Size',
        'Test Set Size',
        'Time Series Days'
    ],
    'Details': [
        f"{len(df_raw):,} rows, {df_raw.shape[1]} columns",
        f"0 missing values (filled/removed)",
        f"Removed ~{len(df_raw) - len(df):,} invalid records",
        f"{len(df):,} rows, {df.shape[1]} columns",
        f"{len(new_features)} new features",
        f"{len(X_train):,} samples ({len(feature_cols) + len(cat_cols)} features)",
        f"{len(X_test):,} samples",
        f"{len(daily_bookings)} days of data"
    ]
})
summary
```

### Feature Summary

```{python}
#| label: final-features

all_features = feature_cols + cat_cols
print(f"Total features for classification: {len(all_features)}")
print("\nFeatures by category:")
print("=" * 50)

print("\nBooking Characteristics:")
booking_feats = ['lead_time', 'arrival_date_week_number', 'arrival_month_num',
                 'stays_in_weekend_nights', 'stays_in_week_nights', 'total_nights',
                 'is_weekend_stay', 'season']
for f in booking_feats:
    if f in all_features:
        print(f"  ✓ {f}")

print("\nGuest Information:")
guest_feats = ['adults', 'children', 'babies', 'total_guests', 
               'is_repeated_guest', 'previous_cancellations', 
               'previous_bookings_not_canceled', 'customer_type']
for f in guest_feats:
    if f in all_features:
        print(f"  ✓ {f}")

print("\nBooking Details:")
detail_feats = ['meal', 'market_segment', 'distribution_channel', 
                'deposit_type', 'booking_changes', 'days_in_waiting_list',
                'required_car_parking_spaces', 'total_of_special_requests',
                'got_reserved_room']
for f in detail_feats:
    if f in all_features:
        print(f"  ✓ {f}")

print("\nPricing:")
price_feats = ['adr', 'hotel']
for f in price_feats:
    if f in all_features:
        print(f"  ✓ {f}")
```

## Next Steps

The data is now ready for modeling:

1. ✅ Missing values handled
2. ✅ Invalid records removed
3. ✅ New features engineered
4. ✅ Categorical variables encoded
5. ✅ Data split into train/test sets
6. ✅ Time series data prepared
7. ✅ All data saved for reproducibility

The next chapter will focus on building and training our prediction models.
